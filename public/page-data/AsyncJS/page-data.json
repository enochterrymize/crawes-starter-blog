{"componentChunkName":"component---src-templates-blog-post-js","path":"/AsyncJS/","result":{"data":{"site":{"siteMetadata":{"title":"<ENOCH />"}},"markdownRemark":{"id":"24e04d69-7707-52db-a88b-6679e3d3a8e8","excerpt":"OK then so now you’re quite familiar with a lot of the javascript language hopefully. I think it’s time to introduce the beast that is asynchronous javascript…","html":"<p>OK then so now you’re quite familiar with a lot of the javascript language hopefully.</p>\n<p>I think it’s time to introduce the beast that is asynchronous javascript.</p>\n<p>When I first started to learn about asynchronous javascript I felt like I was climbing a mountain with no peak.</p>\n<p>And I kept on slipping up along the way as well.</p>\n<blockquote>\n<p>Asynchronous Javascript\nasynchronous javascript is one of the most important parts of the language because it governs how we perform tasks that take some time to do like requesting data from a database or from an API.</p>\n</blockquote>\n<p>And chances are if you’re making a real javascript application then you will be using asynchronous code at some point to do these kinds of things.</p>\n<p>So in a very simplistic nutshell</p>\n<blockquote>\n<p>Asynchronous code is code that can start now and then finish later</p>\n</blockquote>\n<p>but before we talk more about asynchronous code let’s first of all understand its counterpart synchronous code.</p>\n<p>So javascript by its very nature is a synchronous language and that basically means that JavaScript can execute only one statement at a time from top to bottom.</p>\n<p>So for example in a javascript file we could have three statements and each statement is run in turn.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(&quot;one&quot;)</code></pre></div>\n<p>Now line 2 cannot stop before line 1 is finished and Line 3 cannot start before line 2 is finished so it executes these one at a time in order.</p>\n<p>Now you might hear javascript being called a single threaded language and that essentially means the same thing a thread is like an audit sequence of statements and only one of those statements can run at a time.</p>\n<p>So this is the crux of synchronous code one statement being executed at a time after one another.</p>\n<p>Now with this image of synchronous code in mind a single thread and only one statement executed in at a time.</p>\n<p>Imagine this scenario we want to call a bunch of JavaScript functions in a file.</p>\n<p>Some of these functions do quick little things like log something to a console but one of them wants</p>\n<p>to make a network request to a database on another server somewhere to get some data.</p>\n<p>Now this could take 2 or 3 seconds to complete maybe less maybe more so in a synchronous programming</p>\n<p>world because only one statement can run at a time.</p>\n<p>This fetching of data stalls the program.</p>\n<p>This is known as blocking code because it blocks the next line of code from running until it gets the</p>\n<p>data back.</p>\n<p>And this function is complete.</p>\n<p>After those two or three seconds.</p>\n<p>Now in this case you might think well okay.</p>\n<p>Two seconds isn’t that long to wait.</p>\n<p>But what if you have multiple functions to get data then that could soon be five to six seconds off</p>\n<p>six to seven seconds and it would block the rest of the code underneath from running until these things</p>\n<p>are complete.</p>\n<p>So this is a downfall of synchronous code.</p>\n<p>And this is where asynchronous code comes into play to help us out so we know that running our functions</p>\n<p>synchronicity when it comes to task that takes some time to complete is probably then not the best way to work right.</p>\n<p>So remember the definition I first gave you of asynchronous code\n// to start something now and finish it later.</p>\n<p>This is the pattern we generally want to follow when boring tasks that take some time to do like network</p>\n<p>requests for data to a database or an API.</p>\n<p>So imagine we have the same kind of sequence of function calls or statements.</p>\n<p>Only this time instead of this being some kind of synchronous function to request data we use an asynchronous</p>\n<p>function instead.</p>\n<p>And this means the function can start now and then finish later once the data has come back from wherever</p>\n<p>we get it from.</p>\n<p>Now since this function is finishing later what we typically do is pass this function or this statement</p>\n<p>some kind of callback function as a parameter and then that callback function is the thing that runs</p>\n<p>and finishes later on.</p>\n<p>Once the request is complete and the data comes back.</p>\n<p>So how is this all work exactly.</p>\n<p>Well we have our queue of function calls in the code again which executed one at a time so first this</p>\n<p>one then this one and so forth.</p>\n<p>Now remember at all times JavaScript can only execute one thing at a time but this time when we get</p>\n<p>to the request function here we are using an asynchronous function to request the external data.</p>\n<p>What this means is that the browser takes that request and it handles it outside of the scope of this</p>\n<p>single thread in another part of the browser.</p>\n<p>It also takes a callback function and puts it to one side too so that it knows to execute this later</p>\n<p>on when the data comes back.</p>\n<p>So because this network request has been taken out of this Fred he is now running in a different part</p>\n<p>with the browser JavaScript can carry on down the queue and run the remaining functions all the while</p>\n<p>this is still going on.</p>\n<p>The request for data so it continues through these functions and then when it receives the data back</p>\n<p>from the network request and wants the rest of the functions have been executed then we’re allowed to</p>\n<p>call this callback function and finish this original function.</p>\n<p>So this is the crux of asynchronous programming starting something now which can be finished later.</p>\n<p>And it makes our code not blocking because the rest of the functions here they can run while the request</p>\n<p>is being made.</p>\n<p>Now this explanation is a very simplistic one.</p>\n<p>And there are other things at play such as the event loop and the call stack which we have not discussed.</p>\n<p>But I think to delve into that right now would be a bit overwhelming.</p>\n<p>And I think this picture of painted should be enough for now to understand the general idea of asynchronous</p>\n<p>code.</p>\n<p>So now we know a little about what that is and what asynchronous code does.</p>\n<p>Let’s have a look at an example.</p>\n<blockquote>\n<p>Reducer in React\nThe following function is a reducer function for managing state for a list of items:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const todoReducer = (state, action) =&gt;{\n\n}</code></pre></div>\n<blockquote>\n<p>Fields\nA field has a name and type:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">age: Int</code></pre></div>\n<p>The built in scaler types are:\nInt, Float, String, Boolean, ID</p>\n<blockquote>\n<p>Non-nullable fields are denoted by exclamation mark:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">age: Int!</code></pre></div>\n<p>Lists are denoted by square brackets:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">names: [String!]</code></pre></div>\n<blockquote>\n<p>Enum\nEnum is a scalar value that has a specified set of possible values:</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">enum Category {\n    PROGRAMMING_LANGUAGES\n    API_DESIGN\n}</code></pre></div>\n<blockquote>\n<p>Interface\nInterface is a list of fields.\nType must have the same fields all the interface it implements and all interface fields must be of same type.</p>\n</blockquote>\n<blockquote>\n<p>Schema directive\nA directive allows you to attach arbitary information to any other schema definition element</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">name: String! @defaultValue(value:&quot;blogpost&quot;)</code></pre></div>\n<p>Each GRAPHQL implementation can define their own custom directives that add new functionality.</p>\n<blockquote>\n<p>Here is an example of GraphQL Schema:\nSchema consist of base types(data models) and GraphQL operations like query fetching data, mutuation for creating and deleting data; and subscription for changes in real time</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># base type\ntype todo{\n    id:ID\n    name: String\n    completed:Boolean\n}\n# Query definitions\ntype Query {\n    getTodo(id:ID): Todo\n    listTodos: [Todo]\n}\n# Mutation definitions\ntype Mutation {\n    createTodo(input: Todo): Todo\n}\n\n# Subscription definitions\ntype Subscriptions{\n    onCreateTodo: Todo\n}</code></pre></div>","frontmatter":{"title":"ASYNC Javascript ?","date":"January 04, 2021","description":"Asynchronous Javascript"}}},"pageContext":{"slug":"/AsyncJS/","previous":{"fields":{"slug":"/useReducer/"},"frontmatter":{"title":"useReducer ?"}},"next":{"fields":{"slug":"/DeleteDotFiles/"},"frontmatter":{"title":"Delete Dot Files"}}}}}